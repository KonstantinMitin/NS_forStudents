#include "include\\nsProblem.h"
#include <fstream>
#include <time.h>

using namespace std;

//вывести результаты вычислений в файл
void ouptutResults(nsProblem& pr)
{
	ofstream outHeat("Result\\Heat.txt");
	outHeat.precision(16);
	outHeat.setf(ios_base::scientific);

	pr.getMesh().toStream(outHeat, pr.getHeat());
	outHeat.close();

	ofstream outStream("Result\\Stream.txt");
	outStream.precision(16);
	outStream.setf(ios_base::scientific);

	pr.getMesh().toStream(outStream, pr.getStream());
	outStream.close();

	ofstream outVortex("Result\\Vortex.txt");
	outVortex.precision(16);
	outVortex.setf(ios_base::scientific);

	pr.getMesh().toStream(outVortex, pr.getVortex());
	outVortex.close();

	ofstream outVx("Result\\Vx.txt");
	outVx.precision(16);
	outVx.setf(ios_base::scientific);

	pr.getMesh().toStream(outVx, pr.getVx());
	outVx.close();

	ofstream outVy("Result\\Vy.txt");
	outVy.precision(16);
	outVy.setf(ios_base::scientific);

	pr.getMesh().toStream(outVy, pr.getVy());
	outVy.close();

	return;
}

//Квадратная полость, подогрев снизу, все стенки жесткие, число Прандтля - 16, число Грасгофа - 1000
void case1()
{
	//конфигурируем задачу
	nsProblem pr(
					1e+3,		//число Грасгофа
					16,			//число Прандтля
					1,			//безразмерная ширина области
					1,			//безразмерная высота области
					50,			//количество узлов по ширине
					50,			//количество узлов по высоте
					false,		//подогрев снизу
					1e-16,		//точность решения СЛАУ
					1000,		//максимальное количество итераций при решении СЛАУ
					1e-6,		//точность решения системы уравнений
					3000		//максимальное количество итераций при решении системы уравнений
				);

	//запускаем решение задачи
	pr.solve(
					0.3,		//коэффициент релаксации для системы уравнений (уменьшить, если система перестала сходиться)
					cout		//поток для вывода лога
			);

	//выводим результат
	ouptutResults(pr);

	return;
}

//Прямоугольная полость, подогрев снизу, все стенки жесткие, число Прандтля - 16, число Грасгофа - 1000
void case2()
{
	//конфигурируем задачу
	nsProblem pr(
					1e+3,		//число Грасгофа
					16,			//число Прандтля
					10,			//безразмерная ширина области
					1,			//безразмерная высота области
					500,		//количество узлов по ширине
					50,			//количество узлов по высоте
					false,		//подогрев снизу
					1e-16,		//точность решения СЛАУ
					1000,		//максимальное количество итераций при решении СЛАУ
					1e-6,		//точность решения системы уравнений
					10000		//максимальное количество итераций при решении системы уравнений
				);

	//запускаем решение задачи
	pr.solve(
					0.3,		//коэффициент релаксации для системы уравнений
					cout		//поток для вывода лога
			);

	//выводим результат
	ouptutResults(pr);

	return;
}


void case3()
{
	//конфигурируем задачу
	nsProblem pr(
					1e+2,		//число Грасгофа
					19,			//число Прандтля
					4,			//безразмерная ширина области
					1,			//безразмерная высота области
					200,		//количество узлов по ширине
					50,			//количество узлов по высоте
					false,		//подогрев снизу
					1e-16,		//точность решения СЛАУ
					1000,		//максимальное количество итераций при решении СЛАУ
					1e-6,		//точность решения системы уравнений
					10000		//максимальное количество итераций при решении системы уравнений
				);

	//задаем случайное начальное распределение температуры
	pr.addFluctuation(1);

	//запускаем решение задачи
	pr.solve(
					0.3,		//коэффициент релаксации для системы уравнений
					cout		//поток для вывода лога
			);

	//выводим результат
	ouptutResults(pr);

	return;
}

//Квадратная полость, подогрев сбоку, все стенки жесткие, число Прандтля - 16, число Грасгофа - 1000
void case4()
{
	//конфигурируем задачу
	nsProblem pr(
					1e+3,		//число Грасгофа
					16,			//число Прандтля
					1,			//безразмерная ширина области
					1,			//безразмерная высота области
					50,			//количество узлов по ширине
					50,			//количество узлов по высоте
					true,		//подогрев сбоку
					1e-16,		//точность решения СЛАУ
					1000,		//максимальное количество итераций при решении СЛАУ
					1e-6,		//точность решения системы уравнений
					3000		//максимальное количество итераций при решении системы уравнений
				);

	//запускаем решение задачи
	pr.solve(
					0.3,		//коэффициент релаксации для системы уравнений (уменьшить, если система перестала сходиться)
					cout		//поток для вывода лога
			);

	//выводим результат
	ouptutResults(pr);

	return;
}

//Квадратная полость, подогрев сбоку, все стенки жесткие, число Прандтля - 16, число Грасгофа - 1000
void case5()
{
	//конфигурируем задачу
	nsProblem pr(
					1e+6,		//число Грасгофа
					16,			//число Прандтля
					1,			//безразмерная ширина области
					1,			//безразмерная высота области
					100,		//количество узлов по ширине
					100,		//количество узлов по высоте
					true,		//подогрев сбоку
					1e-16,		//точность решения СЛАУ
					1000,		//максимальное количество итераций при решении СЛАУ
					1e-6,		//точность решения системы уравнений
					300			//максимальное количество итераций при решении системы уравнений
				);

	//запускаем решение задачи
	pr.solve(
					0.3,		//коэффициент релаксации для системы уравнений (уменьшить, если система перестала сходиться)
					cout,		//поток для вывода лога
					1./0.0001,	//чем больше, тем стабильнее решение, но тем медленее
					2000		//максимальное количество итераций
			);

	//выводим результат
	ouptutResults(pr);

	return;
}

//Прямоугольная полость, подогрев сбоку, все стенки жесткие, число Прандтля - 16, число Грасгофа - 1000
void case6()
{
	//конфигурируем задачу
	nsProblem pr(
					1e+3,		//число Грасгофа
					16,			//число Прандтля
					1,			//безразмерная ширина области
					4,			//безразмерная высота области
					50,			//количество узлов по ширине
					200,		//количество узлов по высоте
					true,		//подогрев сбоку
					1e-16,		//точность решения СЛАУ
					1000,		//максимальное количество итераций при решении СЛАУ
					1e-6,		//точность решения системы уравнений
					3000		//максимальное количество итераций при решении системы уравнений
				);

	//запускаем решение задачи
	pr.solve(
					0.3,		//коэффициент релаксации для системы уравнений (уменьшить, если система перестала сходиться)
					cout		//поток для вывода лога
			);

	//выводим результат
	ouptutResults(pr);

	return;
}

void main()
{
	case1();
	return;
}